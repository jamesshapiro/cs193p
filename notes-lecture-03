Lecture 3: Swift Highlights:
============================

(1.) Optionals
An Optional is just an enum.

In otherwords ...

enum Optional<T> {
     case none
     case some(T)
}

The "?" and "!" are just syntactic sugar:

let x: String? = nil
... is ...
let x = Optional<String>.none

let x: String? = "hello"
... is ...
let x = Optional<String>.some("hello")

let y = x!
... is ...
switch x {
    case some(let value): y = value
    case non: // raise an exception
}

====================

let x: String? = ...
if let y = x {
    // do something with y
}
... is ...
switch x {
    case .some(let y):
        // do something with y
    case .none:
        break
}

====================
Optionals can be ``chained''

For example, hashValue is a var in String
What if we wanted to get the hashValue from an Optional String?
And what if that Optional String was, itself, the text of an Optional UILabel?

// Ugly
var display: UILabel? // imagine this is an @IBOutlet without the implict unwrap !
if let temp1 = display {
    if let temp2 = temp1.text {
        let x = temp2.hasValue
        ..
    }
}

... with Optional chaining using ? instead of ! to unwrap, this becomes ...
if let x = display?.text?.hashValue { ... } // x is an Int

   let x = display?.text?.hashValue { ... } // x is an Int?

====================

There is also an Optional ``defaulting'' operator: ??
=====================================================
What if we want to put a String into a UILabel, but if it's nil,
  put " " (space) in the UILabel?

let s: String? = ... // might be nil
if s != nil {
    display.text = s
} else {
    display.text = " "
}
    
... can be expressed much more simply this way ...

display.text = s ?? " "

====================

Tuples
======
What is a tuple?

It is nothing more than a grouping of values.
You can use it anywhere you can use a type.

let x: (String, Int Double) = ("hello", 5, 0.85) // the type of x is ``a tuple''
let (word, number, value) = x // this names the tuple elements when accessing the tuple
print(word) // prints hello
print(number) // prints 5
print(value) // prints 0.85

ALTERNATIVELY: (preferred / recommended):
=========================================
let x: (w: String, i: Int, v: Double) = ("hello", 5, 0.85)
print(x.w) // prints helo
print(x.i) // prints 5
print(x.v) // prints 0.85

Tuples as return values.
You can use tuples to return multiple values from a function or method ...
func getSize() -> (weight: Double, height: Double) { return (250, 80) }

let x = getSize()
print("weight is \(x.weight)") // weight is 250
... or ...
print("height is \(getSize().height)") // height is 80

====================

Range
  A Range in Swift is just two end points.
  A range can represent things like a selection in some text or a portion
    of an Array.
Range is generic (e.g. Range<T>), but T is restricted (e.g. comparable).
This is sort of a pseudo-representation of Range ...

struct Range<T> {
    var startIndex: T
    var endIndex: T
}

So, for example, a Range<Int> would be good for a range specifying a slice of an Array.

There are other, more capable, Ranges like CountableRange.

A CountableRange contains consecutive values which can be iterated over or indexed into

Range
-- There is a special syntax for creating a range.
-- Either ..< (exclude the upper bound) or ... (include both boudns)

let array = ["a", "b", "c", "d", "e"]
let a = array[2...3] // a will be a slice of the array containing ["c". "d"]
let b = array[2..<3] // b will be a slice of the array containing ["c". "d"]

let c = array[6...8] // runtime crash (array index out of bounds)
let d = array[2...1] // runtime crash (lower bound must be smaller than upper bound)

A String subrange is *not* Rnage<Int> (it's Range<String.Index>)
let e = "hello"[2..<4] // this != ";;", in fact, it won't evne compile
let f = "hello"[start..<end] // this is possible; we'll explain
                             // start and end a bit later


  